# üóÇÔ∏è Collection

**`#bs.collection:help`**

Functional programming operations for working with collections in Minecraft.

```{image} /_imgs/modules/collection.png
:align: center
:class: dark_light p-2
```

```{pull-quote}
"Simplicity is the ultimate sophistication."

-- Leonardo da Vinci
```

---

## üîß Functions

You can find below all functions available in this module.

---

### Generation Operations

Operations that create new collections.

:::::{tab-set}
::::{tab-item} Range

```{function} #bs.collection:range

Generate a sequence of numbers from `min` (inclusive) to `max` (exclusive) with a specified `step`.

:Inputs:
  **Macro `min`**: {nbt}`int` The starting value (inclusive).
  **Macro `max`**: {nbt}`int` The ending value (exclusive).
  **Macro `step`**: {nbt}`int` The step between each value.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The generated list of integers.
```

*Example: Generate 0, 1, 2, 3, 4:*

```mcfunction
function #bs.collection:range {min: 0, max: 5, step: 1}
# bs:out collection.value = [0, 1, 2, 3, 4]
```

::::
::::{tab-item} Repeat

```{function} #bs.collection:repeat

Create a collection containing `count` copies of `value`.

:Inputs:
  **Macro `value`**: {nbt}`any` The value to repeat (must be a valid SNBT string).
  **Macro `count`**: {nbt}`int` The number of times to repeat the value.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The generated list.
```

*Example: Repeat a value 3 times:*

```mcfunction
function #bs.collection:repeat {value: 5, count: 3}
# bs:out collection.value = [5, 5, 5]
```

::::
::::{tab-item} Generate

```{function} #bs.collection:generate

Generate a collection by repeatedly calling a generator function up to a limit.

:Inputs:
  **Macro `run`**: {nbt}`string` The command to execute to generate a value. The command must set `bs:lambda collection.result`.
  **Macro `limit`**: {nbt}`int` The number of values to generate.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The generated list.

:Lambda Context:
  **Storage `bs:lambda collection.index`**: {nbt}`int` The current index being generated (0-based).
```

*Example: Generate [0, 1, 2]:*

```mcfunction
function #bs.collection:generate {run: "data modify storage bs:lambda collection.result set from storage bs:lambda collection.index", limit: 3}
# bs:out collection.value = [0, 1, 2]
```

::::
::::{tab-item} Generate While

```{function} #bs.collection:generate_while

Generate a collection by repeatedly calling a generator function while a predicate is met.

:Inputs:
  **Macro `run`**: {nbt}`string` The command to execute to generate a value. The command must set `bs:lambda collection.result`.
  **Macro `predicate`**: {nbt}`string` The predicate to check on the generated value. Returns success to continue, fail to stop.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The generated list.

:Lambda Context:
  **Storage `bs:lambda collection.index`**: {nbt}`int` The current index being generated (0-based).
  **Storage `bs:lambda collection.result`**: {nbt}`any` The value generated by `run`, available in the `predicate` check.
```

*Example: Generate values equal to index until index is 3:*

```mcfunction
function #bs.collection:generate_while {run: "data modify storage bs:lambda collection.result set from storage bs:lambda collection.index", predicate: "execute if score #i bs.ctx matches ..2"}
# bs:out collection.value = [0, 1, 2]
```

::::
:::::

---

### Iteration Operations

Operations for looping over elements without necessarily returning a new collection.

:::::{tab-set}
::::{tab-item} ForEach

```{function} #bs.collection:foreach

Execute an operation on each element of a collection.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to iterate over.

  **Macro `run`**: {nbt}`string` Lambda function to execute on each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index).

:Outputs:
  None. This function is used for side effects only.
```

*Example: Display each element:*

```mcfunction
data modify storage bs:out collection.value set value ["Hello", "World", "!"]
function #bs.collection:foreach {run: "tellraw @a [{\"storage\":\"bs:lambda\",\"nbt\":\"collection.value\"}]"}
# Displays each string to all players
```

::::
::::{tab-item} Peek

```{function} #bs.collection:peek

Execute an operation on each element of a collection and return the original collection. Useful for debugging or side effects in a chain of operations.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to iterate over.

  **Macro `run`**: {nbt}`string` Lambda function to execute on each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index).

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The original collection, unchanged.
```

*Example: Log elements while processing:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
# Log each element then continue with other operations
function #bs.collection:peek {run: "tellraw @a [{\"text\":\"Processing: \"},{\"storage\":\"bs:lambda\",\"nbt\":\"collection.value\"}]"}
# bs:out collection.value = [1, 2, 3]
```

::::
::::{tab-item} Tap

```{function} #bs.collection:tap

Execute an operation on the entire collection. Useful for side effects or logging the collection state.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to process.

  **Macro `run`**: {nbt}`string` Lambda function to execute. Receives `bs:lambda collection.value` which is the entire collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The original collection, unchanged.
```

*Example: Log the size of the collection:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
function #bs.collection:tap {run: "tellraw @a [{\"text\":\"Collection: \"},{\"storage\":\"bs:lambda\",\"nbt\":\"collection.value\"}]"}
# bs:out collection.value = [1, 2, 3]
```

::::
:::::

---

### Filtering Operations

Operations that select specific elements from a collection.

:::::{tab-set}
::::{tab-item} Filter

```{function} #bs.collection:filter

Keep only elements that satisfy a predicate condition.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to filter.

  **Macro `run`**: {nbt}`string` Predicate function to test each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index). Must return success (1) to keep the element.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The filtered collection containing only matching elements.
```

*Example: Keep only even numbers:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5, 6]
function #bs.collection:filter {run: "execute store success score #r bs.ctx run data get storage bs:lambda collection.value"}
# Further filtering logic needed for even check
```

::::
::::{tab-item} Take

```{function} #bs.collection:take

Take the first N elements from a collection.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to take from.

  **Macro `number`**: {nbt}`int` The number of elements to take.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection containing only the first N elements.
```

*Example: Take first 3 elements:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:take {number: 3}
# bs:out collection.value = [1, 2, 3]
```

::::
::::{tab-item} Take While

```{function} #bs.collection:take_while

Take elements from the beginning of a collection as long as a predicate is true.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to take from.

  **Macro `run`**: {nbt}`string` Predicate function. Receives `bs:lambda collection.value` and `bs:lambda collection.index`. Must return success (1) to continue taking.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The elements taken.
```

*Example: Take elements while they are less than 3:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:take_while {run: "execute if data storage bs:lambda collection.value < 3"}
# bs:out collection.value = [1, 2]
```

::::
::::{tab-item} Drop

```{function} #bs.collection:drop

Drop the first N elements from a collection.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to drop from.

  **Macro `number`**: {nbt}`int` The number of elements to drop.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection with the first N elements removed.
```

*Example: Drop first 2 elements:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:drop {number: 2}
# bs:out collection.value = [3, 4, 5]
```

::::
::::{tab-item} Drop While

```{function} #bs.collection:drop_while

Drop elements from the beginning of a collection as long as a predicate is true.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to drop from.

  **Macro `run`**: {nbt}`string` Predicate function. Receives `bs:lambda collection.value` and `bs:lambda collection.index`. Must return success (1) to continue dropping.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The remaining elements.
```

*Example: Drop elements while they are less than 3:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:drop_while {run: "execute if data storage bs:lambda collection.value < 3"}
# bs:out collection.value = [3, 4, 5]
```

::::
::::{tab-item} Slice

```{function} #bs.collection:slice

Extract a portion of a collection from `min` (inclusive) to `max` (exclusive). Supports negative indices (counted from the end).
The function fails if `min >= max`, or if indices are out of bounds (after negative index resolution).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to slice.
  **Macro `min`**: {nbt}`int` The start index (inclusive).
  **Macro `max`**: {nbt}`int` The end index (exclusive).

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The sliced collection.
```

*Example: Get elements from index 1 to 3:*

```mcfunction
data modify storage bs:out collection.value set value [0, 1, 2, 3, 4]
function #bs.collection:slice {min: 1, max: 3}
# bs:out collection.value = [1, 2]
```

::::
::::{tab-item} Partition

```{function} #bs.collection:partition

Split a collection into two collections based on a predicate: one containing elements that match the predicate, and one containing elements that don't.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to partition.

  **Macro `run`**: {nbt}`string` Predicate function to test each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index). Must return success (1) for match, fail (0) otherwise.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` A list containing two lists: `[matches, non_matches]`.
```

*Example: Partition even and odd numbers:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
# Assume is_even returns 1 for even numbers, 0 for odd
function #bs.collection:partition {run: "function mypack:is_even"}
# bs:out collection.value = [[2, 4], [1, 3, 5]]
```

::::
::::{tab-item} Distinct

```{function} #bs.collection:distinct

Remove duplicate elements from a collection, keeping only the first occurrence of each element.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to process.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection with duplicates removed.
```

*Example: Remove duplicates:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 2, 3, 1]
function #bs.collection:distinct
# bs:out collection.value = [1, 2, 3]
```

::::
:::::

---

### Transformation Operations

Operations that transform elements or the structure of the collection.

:::::{tab-set}
::::{tab-item} Map

```{function} #bs.collection:map

Transform each element of a collection using a lambda function.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to transform.

  **Macro `run`**: {nbt}`string` Lambda function to execute on each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index).

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The transformed collection.
```

*Example: Double each number in a list:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:map {run: "return run data get storage bs:lambda collection.value 2"}
# bs:out collection.value = [2, 4, 6, 8, 10]
```

::::
::::{tab-item} Flatmap

```{function} #bs.collection:flatmap

Transform each element into a collection and flatten the results into a single collection.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to transform.

  **Macro `run`**: {nbt}`string` Lambda function to execute on each element. Receives `bs:lambda collection.value` (element value) and `bs:lambda collection.index` (element index).

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The flattened transformed collection.
```

*Example: Transform each number into a list of its multiples and flatten:*

```mcfunction
# This would require a custom function that returns a list
data modify storage bs:out collection.value set value [1, 2, 3]
function #bs.collection:flatmap {run: "function mypack:get_multiples"}
# If get_multiples returns [n, n*2] for each n, result would be [1, 2, 2, 4, 3, 6]
```

::::
::::{tab-item} Flatten

```{function} #bs.collection:flatten

Flatten a nested collection by one level.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The nested collection to flatten.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The flattened collection.
```

*Example: Flatten a 2D array:*

```mcfunction
data modify storage bs:out collection.value set value [[1, 2], [3, 4], [5]]
function #bs.collection:flatten
# bs:out collection.value = [1, 2, 3, 4, 5]
```

::::
::::{tab-item} Reverse

```{function} #bs.collection:reverse

Reverse the order of elements in a collection.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to reverse.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection with elements in reversed order.
```

*Example: Reverse a list:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:reverse
# bs:out collection.value = [5, 4, 3, 2, 1]
```

::::
::::{tab-item} Scale

```{function} #bs.collection:scale

Multiply all numbers in a collection by a scaling factor.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection of numbers to scale.

  **Macro `scale`**: {nbt}`float` The scaling factor (multiplier).

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection with all values multiplied by the scale.
```

*Example: Multiply all elements by 10:*

```mcfunction
data modify storage bs:out collection.value set value [1.5d, 2.5d]
function #bs.collection:scale {scale: 10}
# bs:out collection.value = [15, 25]
```

::::
::::{tab-item} Chunk

```{function} #bs.collection:chunk

Split a collection into chunks of size N. If the collection size is not divisible by N, the last chunk will contain the remaining elements.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to split.

  **Macro `size`**: {nbt}`int` The size of each chunk.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The list of chunks (list of lists).
```

*Example: Chunk a list into pairs:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:chunk {size: 2}
# bs:out collection.value = [[1, 2], [3, 4], [5]]
```

::::
::::{tab-item} Sliding

```{function} #bs.collection:sliding

Create sliding windows of elements from the collection.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to process.

  **Macro `size`**: {nbt}`int` The number of elements in each window.

  **Macro `step`**: {nbt}`int` The number of elements to shift the window by.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` A list of windows (list of lists).
```

*Example: Sliding window of size 2 with step 1:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4]
function #bs.collection:sliding {size: 2, step: 1}
# bs:out collection.value = [[1, 2], [2, 3], [3, 4]]
```

::::
::::{tab-item} Zip

```{function} #bs.collection:zip

Combine two collections into a list of pairs.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The first collection.
  **Storage `bs:in collection`**: {nbt}`list` The second collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` A list of pairs `[[a1, b1], [a2, b2], ...]`. Truncated to the length of the shorter collection.
```

*Example: Zip two lists:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
data modify storage bs:in collection set value [4, 5]
function #bs.collection:zip
# bs:out collection.value = [[1, 4], [2, 5]]
```

::::
::::{tab-item} Concat

```{function} #bs.collection:concat

Concatenate a list of lists into a single list.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` A list of lists to concatenate.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The flattened list containing all elements from the sub-lists in order.
```

*Example: Concatenate lists:*

```mcfunction
data modify storage bs:out collection.value set value [[1, 2], [3], [4, 5]]
function #bs.collection:concat
# bs:out collection.value = [1, 2, 3, 4, 5]
```

::::
:::::

---

### Aggregation Operations

Operations that combine elements into a single result or a series of results.

:::::{tab-set}
::::{tab-item} Reduce

```{function} #bs.collection:reduce

Reduce a collection to a single value by applying a function that combines the accumulator with each element.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to reduce.

  **Macro `run`**: {nbt}`string` Lambda function that combines accumulator and value.

:Outputs:
  **Storage `bs:out collection.value`**: The final accumulated value.

  **Return**: 0 on success, fail if the collection is empty.
```

*Example: Sum all numbers using reduce:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:reduce {run: "bs.collection:sum_tmp"}
# bs:out collection.value = 15
```

::::
::::{tab-item} Reduce Right

```{function} #bs.collection:reduce_right

Reduce a collection to a single value by applying a function from right to left, starting with the last element as the initial accumulator.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to reduce.

  **Macro `run`**: {nbt}`string` Lambda function that combines accumulator and value.

:Outputs:
  **Storage `bs:out collection.value`**: The final accumulated value.

  **Return**: 0 on success, fail if the collection is empty.
```

::::
::::{tab-item} Fold

```{function} #bs.collection:fold

Reduce a collection to a single value by applying a function that combines the accumulator with each element, starting with a provided initial value.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to fold.

  **Macro `run`**: {nbt}`string` Lambda function that combines accumulator and value.

  **Macro `initial`**: {nbt}`any` Initial value for the accumulator. Must be a valid SNBT value.

:Outputs:
  **Storage `bs:out collection.value`**: The final accumulated value.

  **Return**: 0 on success.
```

*Example: Sum with initial value:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3, 4, 5]
function #bs.collection:fold {run: "bs.collection:sum_tmp", initial: 10}
# bs:out collection.value = 25 (10 + 1 + 2 + 3 + 4 + 5)
```

::::
::::{tab-item} Fold Right

```{function} #bs.collection:fold_right

Reduce a collection to a single value by applying a function from right to left with a provided initial value.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to fold.

  **Macro `run`**: {nbt}`string` Lambda function that combines accumulator and value.

  **Macro `initial`**: {nbt}`any` Initial value for the accumulator.

:Outputs:
  **Storage `bs:out collection.value`**: The final accumulated value.

  **Return**: 0 on success.
```

::::
::::{tab-item} Scanr

```{function} #bs.collection:scanr

Similar to `reduce`, but returns a list of all intermediate accumulator values.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to scan.
  **Macro `run`**: {nbt}`string` Lambda function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The list of intermediate results.
```

::::
::::{tab-item} Scanr Right

```{function} #bs.collection:scanr_right

Similar to `reduce_right`, but returns a list of all intermediate accumulator values.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to scan.
  **Macro `run`**: {nbt}`string` Lambda function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The list of intermediate results.
```

::::
::::{tab-item} Scanf

```{function} #bs.collection:scanf

Similar to `fold`, but returns a list of all intermediate accumulator values.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to scan.
  **Macro `run`**: {nbt}`string` Lambda function.
  **Macro `initial`**: {nbt}`any` Initial value.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The list of intermediate results.
```

::::
::::{tab-item} Scanf Right

```{function} #bs.collection:scanf_right

Similar to `fold_right`, but returns a list of all intermediate accumulator values.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to scan.
  **Macro `run`**: {nbt}`string` Lambda function.
  **Macro `initial`**: {nbt}`any` Initial value.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The list of intermediate results.
```

::::
::::{tab-item} Count

```{function} #bs.collection:count

Count the number of elements in a collection.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to count.

:Outputs:
  **Return**: Integer count of elements in the collection.
```

::::
::::{tab-item} Min

```{function} #bs.collection:imin

Find the minimum value in a collection of integers.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection of integers.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`int` The minimum value.
```

::::
::::{tab-item} Max

```{function} #bs.collection:imax

Find the maximum value in a collection of integers.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection of integers.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`int` The maximum value.
```

::::
::::{tab-item} Sum

```{function} #bs.collection:isum

Calculate the sum of all numbers in a collection (integers).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection of numbers.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`int` The sum.
```

::::
::::{tab-item} Average

```{function} #bs.collection:iaverage

Calculate the average (mean) of a collection of numbers (integers).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection of numbers.
  **Macro `scale`**: {nbt}`int` Scale factor.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`double` The average.
```

::::
:::::

---

### Set Operations

Operations treating collections as sets.

:::::{tab-set}
::::{tab-item} Union

```{function} #bs.collection:union

Compute the union of two collections (elements present in either collection, without duplicates).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The first collection.
  **Storage `bs:in collection`**: {nbt}`list` The second collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The union of the two collections.
```

*Example: Union of [1, 2] and [2, 3]:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2]
data modify storage bs:in collection set value [2, 3]
function #bs.collection:union
# bs:out collection.value = [1, 2, 3]
```

::::
::::{tab-item} Intersect

```{function} #bs.collection:intersect

Compute the intersection of two collections (elements present in both collections, without duplicates).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The first collection.
  **Storage `bs:in collection`**: {nbt}`list` The second collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The intersection of the two collections.
```

*Example: Intersect [1, 2, 3] and [2, 3, 4]:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
data modify storage bs:in collection set value [2, 3, 4]
function #bs.collection:intersect
# bs:out collection.value = [2, 3]
```

::::
::::{tab-item} Difference

```{function} #bs.collection:difference

Compute the difference of two collections (elements present in the first collection but not in the second, without duplicates).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The first collection.
  **Storage `bs:in collection`**: {nbt}`list` The second collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The difference of the two collections.
```

*Example: Difference of [1, 2, 3] and [2, 3, 4]:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
data modify storage bs:in collection set value [2, 3, 4]
function #bs.collection:difference
# bs:out collection.value = [1]
```

::::
::::{tab-item} Symmetric Difference

```{function} #bs.collection:symmetric_difference

Compute the symmetric difference of two collections (elements present in either collection, but not in both, without duplicates).

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The first collection.
  **Storage `bs:in collection`**: {nbt}`list` The second collection.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The symmetric difference of the two collections.
```

*Example: Symmetric difference of [1, 2, 3] and [2, 3, 4]:*

```mcfunction
data modify storage bs:out collection.value set value [1, 2, 3]
data modify storage bs:in collection set value [2, 3, 4]
function #bs.collection:symmetric_difference
# bs:out collection.value = [1, 4]
```

::::
:::::

---

### Search & Check Operations

Operations for finding elements or validating conditions.

:::::{tab-set}
::::{tab-item} Find

```{function} #bs.collection:find

Find the first element that satisfies a predicate condition.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to search.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`any` The first matching element.
  **Storage `bs:out collection.index`**: {nbt}`int` The index.
  **Return**: Success (1) if element found.
```

::::
::::{tab-item} Find Last

```{function} #bs.collection:find_last

Find the last element that satisfies a predicate condition.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to search.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`any` The last matching element.
  **Storage `bs:out collection.index`**: {nbt}`int` The index.
```

::::
::::{tab-item} Index Of

```{function} #bs.collection:index_of

Find the index of the first element matching a predicate.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to search.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`int` The zero-based index of the first matching element, or -1.
```

::::
::::{tab-item} Last Index Of

```{function} #bs.collection:last_index_of

Find the index of the last element matching a predicate.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to search.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Storage `bs:out collection.value`**: {nbt}`int` The zero-based index of the last matching element, or -1.
```

::::
::::{tab-item} Contains

```{function} #bs.collection:contains

Check if a collection contains a specific value.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to search.
  **Macro `searched`**: {nbt}`any` The value to search for.

:Outputs:
  **Return**: Success (1) if found, fail (0) otherwise.
```

::::
::::{tab-item} Any

```{function} #bs.collection:any

Test if at least one element satisfies a predicate condition.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to test.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Return**: Success (1) if any element matches.
```

::::
::::{tab-item} All

```{function} #bs.collection:all

Test if all elements satisfy a predicate condition.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to test.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Return**: Success (1) if all elements match.
```

::::
::::{tab-item} None

```{function} #bs.collection:none

Test if no elements satisfy a predicate condition.

:Inputs:
  **Storage `bs:in collection`**: {nbt}`list` The collection to test.
  **Macro `run`**: {nbt}`string` Predicate function.

:Outputs:
  **Return**: Success (1) if no elements match.
```

::::
::::{tab-item} Is Empty

```{function} #bs.collection:is_empty

Test if a collection is empty.

:Inputs:
  **Storage `bs:out collection.value`**: {nbt}`list` The collection to test.

:Outputs:
  **Return**: Success (1) if empty.
```

::::
:::::

---

## üí° Understanding Lambda Functions

All collection operations use **lambda functions** passed via the `run` macro parameter. These functions have access to:

- **`bs:lambda collection.value`**: The current element being processed
- **`bs:lambda collection.index`**: The zero-based index of the current element

### Lambda Return Values

- **Transformation operations** (`map`, `flatmap`): Should return a value that will be added to the result
- **Predicate operations** (`filter`, `find`, `any`, `all`, `none`): Should return success (1) or fail (0)
- **Iteration operations** (`foreach`): Return value is ignored

### Examples

```mcfunction
# Map: Double each number
function #bs.collection:map {run: "return run data get storage bs:lambda collection.value 2"}

# Filter: Keep only elements at even indices
function #bs.collection:filter {run: "execute store result score #r bs.ctx run data get storage bs:lambda collection.index"}
# Additional modulo check needed

# Any: Check if value 5 exists
function #bs.collection:any {run: "execute if data storage bs:lambda collection{value: 5}"}

# ForEach: Log each element
function #bs.collection:foreach {run: "tellraw @a [{\"score\":{\"name\":\"#i\",\"objective\":\"bs.ctx\"}},{\"text\":\": \"},{\"storage\":\"bs:lambda\",\"nbt\":\"collection.value\"}]"}
```

---

## ‚ö° Performance Considerations

- All operations use **recursive processing** and process elements sequentially
- **Short-circuit evaluation**: `any`, `all`, `none`, and `find` stop processing as soon as the result is determined
- **Empty collections**: Return immediately with appropriate default values
- **Lambda overhead**: Each element invokes the lambda function, so complex lambdas impact performance

---

## üìù Credits

> **Module Design**: Bookshelf Team
